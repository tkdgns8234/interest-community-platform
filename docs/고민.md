1. Request,Response DTO 와 Service Layer 분리
    - DTO 변경에 따른 Service 오염 그 반대도 방지
    - 서로 다른 Layer 간 의존성 방지
2. 패키지 구조 설계
    - Layer 별 패키지 분리 (controller, service, repository, domain)
    - 도메인 별 패키지 분리 (user, post, comment)
3. Exception 처리 전략
    - 공통 예외 처리기 구현 (ControllerAdvice)
    - Application / Domain 예외 구분
4. Rest API 응답 표준화
    - 성공
      - 성공도 응답을 표준화 할 것인가? -> ex) code, message, data={}
      - Rest 표준 응답 구조 설계 (성공 여부는 Status Code 로 구분, 응답 Body 에는 데이터만 포함)
    - 실패
      - 실패 응답 표준화
      - 도메인, 애플리케이션 예외 구분
5. Value Object 활용
    - 식별자가 필요 없는 도메인 속성에 Value Object 적용
    - 불변 객체로 설계
6. 디미터 법칙을 강하게 준수할것인지와 관련된 적절한 trade off
    - targetUser.followManager.increaseFollowerCount(); // 객체지향 생활체조원칙 디미터법칙 위반이지만, 향후 follow 작업 관련 기능 확장(알림 등)이 있는 경우 followManager 에서 처리 가능함 (복잡성 줄이기위한 일부 trade-off)
7. Common Object 의 경우 동시성문제 등 상대적으로 안전한 Value Object 형태로 설계
8. 도메인과 엔티티를 분리
    - 도메인은 순수 비즈니스 로직
    - 엔티티는 데이터 저장 및 조회 책임
    - 분리하면서 생기는 복잡성.. 등은 추후 고려 필요해보임
9. UseCase 적용은 MVP 수준에서는 오히려 복잡성 증가 요인으로 판단되어 보류
    - 추후 서비스 복잡도가 증가할 경우 도입 고려
10. 외부에서 소셜 계정 생성시 발생하는 세부내용을 알 필요 없음 (로컬 계정인지 소셜 계정인지에 따른 ~~ 작업)
   - 외부에서 소셜 계정 생성 세부내용을 알 필요 없음, 추상화 된 정적 팩토리 메서드 제공
11. FollowManager는 Value Object 인가?
    - 팔로워 수와 팔로잉 수를 관리하는 클래스
    - ValueObject 적용을 고려하였으나, User 도메인의 내부 구현을 캡슐화한 객체에 더 가깝다고 판단. 현재 구현 유지
12. val 의 허용 범위, 남발해도 되는가?
    - kotlin 스러운 장점, 가독성 증가
    - Controller 단 Command 객체 선언 처럼 값의 타입이 중요하지 않은 경우 유용
    - 단점: 변수 타입이 명확하지 않은 경우 가독성 저하 우려 (도메인 모델에서는 명시적 타입 선언)
13. Aggregate Root 간 통신 방법
    - 종단간 동기적 통신이 필요한 경우
        - API 통신? -> 굳이.. 추후 MSA 구조로 쉽게 이관할 수 있도록 구현하는것을 목표
        - Application/Domain Service 에서 조율
          - **인터페이스 통해 간접 참조**하여 추후 API 통신이나 메시지 큐 등으로 전환 용이하도록 설계
    - 그 외 시스템의 복잡성을 높이지 않는 범위 내에서 비동기적 통신이 가능한 경우
      - 도메인 이벤트 발행
14. User Follow 시나리오에서 현재 Following 중인지 체크하는 로직이 Application Service 에 포함되어 있는데, 
비즈니스 룰 이니 도메인 쪽으로 옮기는 것이 좋지 않은가?
    - DB 조회가 필요한 로직이므로 도메인 쪽으로 옮기기 어려움
    - 도메인 쪽으로 옮기려면 도메인 서비스로 구현
      - UserRelationService 내부 로직 -> UserRelationPolicy